(function() {
  'use strict';

  var globals = typeof window === 'undefined' ? global : window;
  if (typeof globals.require === 'function') return;

  var modules = {};
  var cache = {};
  var has = ({}).hasOwnProperty;

  var aliases = {};

  var endsWith = function(str, suffix) {
    return str.indexOf(suffix, str.length - suffix.length) !== -1;
  };

  var unalias = function(alias, loaderPath) {
    var start = 0;
    if (loaderPath) {
      if (loaderPath.indexOf('components/' === 0)) {
        start = 'components/'.length;
      }
      if (loaderPath.indexOf('/', start) > 0) {
        loaderPath = loaderPath.substring(start, loaderPath.indexOf('/', start));
      }
    }
    var result = aliases[alias + '/index.js'] || aliases[loaderPath + '/deps/' + alias + '/index.js'];
    if (result) {
      return 'components/' + result.substring(0, result.length - '.js'.length);
    }
    return alias;
  };

  var expand = (function() {
    var reg = /^\.\.?(\/|$)/;
    return function(root, name) {
      var results = [], parts, part;
      parts = (reg.test(name) ? root + '/' + name : name).split('/');
      for (var i = 0, length = parts.length; i < length; i++) {
        part = parts[i];
        if (part === '..') {
          results.pop();
        } else if (part !== '.' && part !== '') {
          results.push(part);
        }
      }
      return results.join('/');
    };
  })();
  var dirname = function(path) {
    return path.split('/').slice(0, -1).join('/');
  };

  var localRequire = function(path) {
    return function(name) {
      var absolute = expand(dirname(path), name);
      return globals.require(absolute, path);
    };
  };

  var initModule = function(name, definition) {
    var module = {id: name, exports: {}};
    cache[name] = module;
    definition(module.exports, localRequire(name), module);
    return module.exports;
  };

  var require = function(name, loaderPath) {
    var path = expand(name, '.');
    if (loaderPath == null) loaderPath = '/';
    path = unalias(name, loaderPath);

    if (has.call(cache, path)) return cache[path].exports;
    if (has.call(modules, path)) return initModule(path, modules[path]);

    var dirIndex = expand(path, './index');
    if (has.call(cache, dirIndex)) return cache[dirIndex].exports;
    if (has.call(modules, dirIndex)) return initModule(dirIndex, modules[dirIndex]);

    throw new Error('Cannot find module "' + name + '" from '+ '"' + loaderPath + '"');
  };

  require.alias = function(from, to) {
    aliases[to] = from;
  };

  require.register = require.define = function(bundle, fn) {
    if (typeof bundle === 'object') {
      for (var key in bundle) {
        if (has.call(bundle, key)) {
          modules[key] = bundle[key];
        }
      }
    } else {
      modules[bundle] = fn;
    }
  };

  require.list = function() {
    var result = [];
    for (var item in modules) {
      if (has.call(modules, item)) {
        result.push(item);
      }
    }
    return result;
  };

  require.brunch = true;
  globals.require = require;
})();
require.register("app", function(exports, require, module) {
// Generated by LiveScript 1.3.1
var ref$, mkRealtimeInput, mkRadiobox, weblibTest, stateOf, radioboxHandler, radioboxListenerHandler, connectEnterToClick, flatten, initial, drop, join, concat, tail, head, map, zip, split, union, url, arr, addr_port, socketioPath, socket, ActorBase, ActorManager, Actor, ProxyActor, SwitchActor, app, setSwitchButtons, setPushButtons, setStatusLeds;
ref$ = require('./weblib'), mkRealtimeInput = ref$.mkRealtimeInput, mkRadiobox = ref$.mkRadiobox, weblibTest = ref$.test, stateOf = ref$.stateOf, radioboxHandler = ref$.radioboxHandler, radioboxListenerHandler = ref$.radioboxListenerHandler, connectEnterToClick = ref$.connectEnterToClick;
flatten = prelude.flatten;
initial = prelude.initial;
drop = prelude.drop;
join = prelude.join;
concat = prelude.concat;
tail = prelude.tail;
head = prelude.head;
map = prelude.map;
zip = prelude.zip;
split = prelude.split;
union = prelude.union;
/* initialize socket.io connections */
url = window.location.href;
arr = url.split("/");
addr_port = arr[0] + "//" + arr[2];
socketioPath = [''].concat(initial(drop(3, arr)), ['socket.io']);
socketioPath = join('/', socketioPath);
socket = io.connect(addr_port, {
  path: socketioPath
});
ActorBase = (function(){
  ActorBase.displayName = 'ActorBase';
  var prototype = ActorBase.prototype, constructor = ActorBase;
  function ActorBase(){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.actorId = uuid4();
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  prototype.receive = function(msg){};
  prototype.recv = function(msg){
    var e;
    this.receive(msg);
    try {
      return this['handle_' + msg.cls](msg);
    } catch (e$) {
      return e = e$;
    }
  };
  return ActorBase;
}());
ActorManager = (function(){
  ActorManager.displayName = 'ActorManager';
  var instance, SingletonClass, prototype = ActorManager.prototype, constructor = ActorManager;
  instance = null;
  function ActorManager(){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    instance == null && (instance = SingletonClass());
    return instance;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  SingletonClass = (function(superclass){
    var prototype = extend$((import$(SingletonClass, superclass).displayName = 'SingletonClass', SingletonClass), superclass).prototype, constructor = SingletonClass;
    function SingletonClass(){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      SingletonClass.superclass.apply(this$, arguments);
      this$.actorList = [];
      return this$;
    } function ctor$(){} ctor$.prototype = prototype;
    prototype.register = function(actor){
      return this.actorList = this.actorList.concat([actor]);
    };
    prototype.inboxPut = function(msg){
      var i$, ref$, len$, actor, results$ = [];
      msg.sender = msg.sender.concat([this.actorId]);
      for (i$ = 0, len$ = (ref$ = this.actorList).length; i$ < len$; ++i$) {
        actor = ref$[i$];
        if (!in$(actor.actorId, msg.sender)) {
          results$.push(actor.recv(msg));
        }
      }
      return results$;
    };
    return SingletonClass;
  }(ActorBase));
  return ActorManager;
}());
Actor = (function(superclass){
  var prototype = extend$((import$(Actor, superclass).displayName = 'Actor', Actor), superclass).prototype, constructor = Actor;
  function Actor(name){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    Actor.superclass.apply(this$, arguments);
    this$.mgr = ActorManager();
    this$.mgr.register(this$);
    this$.name = name;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  prototype.send = function(msg){
    msg = this.fillMsg(msg);
    msg.sender = msg.sender.concat([this.actorId]);
    return this.mgr.inboxPut(msg);
  };
  prototype.copyMsg = function(msg){
    return JSON.parse(JSON.stringify(msg));
  };
  prototype.fillMsg = function(msg){
    var cls;
    cls = Object.keys(msg)[0];
    msg = this.copyMsg(msg[cls]);
    msg.cls = cls;
    msg.sender == null && (msg.sender = []);
    msg.timestamp == null && (msg.timestamp = Date.now() / 1000 || 0);
    msg.msg_id = uuid4();
    return msg;
  };
  return Actor;
}(ActorBase));
ProxyActor = (function(){
  ProxyActor.displayName = 'ProxyActor';
  var instance, SingletonClass, prototype = ProxyActor.prototype, constructor = ProxyActor;
  instance = null;
  function ProxyActor(){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    instance == null && (instance = SingletonClass());
    return instance;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  SingletonClass = (function(superclass){
    var prototype = extend$((import$(SingletonClass, superclass).displayName = 'SingletonClass', SingletonClass), superclass).prototype, constructor = SingletonClass;
    function SingletonClass(){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      SingletonClass.superclass.apply(this$, arguments);
      this$.socket = socket;
      this$.socket.on('aktos-message', function(msg){
        var e;
        try {
          return this$.networkRx(msg);
        } catch (e$) {
          e = e$;
          return console.log("Problem with receiving message: ", e);
        }
      });
      this$.connected = false;
      this$.socket.on("connect", function(){
        this$.connected = true;
      });
      this$.socket.on("disconnect", function(){
        this$.connected = false;
      });
      return this$;
    } function ctor$(){} ctor$.prototype = prototype;
    prototype.networkRx = function(msg){
      return this.send(msg);
    };
    prototype.fillMsg = function(msg){
      return msg;
    };
    prototype.receive = function(msg){
      msg.sender = msg.sender.concat([this.actorId]);
      return this.socket.emit('aktos-message', msg);
    };
    return SingletonClass;
  }(Actor));
  return ProxyActor;
}());
/*

# aktos widget library

## basic types:

toggle-switch: toggles on every tap or click
push-button : toggles while clicking or tapping
status-led : readonly of toggle-switch or push-button

*/
SwitchActor = (function(superclass){
  var prototype = extend$((import$(SwitchActor, superclass).displayName = 'SwitchActor', SwitchActor), superclass).prototype, constructor = SwitchActor;
  function SwitchActor(pinName){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    SwitchActor.superclass.apply(this$, arguments);
    this$.listenerFunctions = [];
    this$.pinName = String(pinName);
    this$.send({
      UpdateIoMessage: {}
    });
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  prototype.addListener = function(func){
    return this.listenerFunctions = this.listenerFunctions.concat([func]);
  };
  prototype.handle_IoMessage = function(msg){
    var i$, ref$, len$, func, results$ = [];
    if (msg.pin_name === this.pinName) {
      for (i$ = 0, len$ = (ref$ = this.listenerFunctions).length; i$ < len$; ++i$) {
        func = ref$[i$];
        results$.push(func(msg));
      }
      return results$;
    }
  };
  prototype.sendEvent = function(val){
    return this.send({
      IoMessage: {
        pin_name: this.pinName,
        val: val
      }
    });
  };
  return SwitchActor;
}(Actor));
ProxyActor();
app = new Ractive({
  template: '#app',
  el: 'container',
  data: {
    connected: false
  },
  onrender: function(options){
    this.set("text", "initial text value");
    console.log('just rendered...');
  }
});
setSwitchButtons = function(){
  $('.toggle-switch').each(function(){
    var elem, elemDom, pinId, actor, s;
    elem = $(this);
    elemDom = elem[0];
    pinId = elem.prop('value');
    actor = SwitchActor(pinId);
    elem.change(function(){
      return actor.sendEvent(this.checked);
    });
    actor.addListener(function(msg){
      return elem.prop('checked', msg.val);
    });
    s = new ToggleSwitch(elemDom, 'on', 'off');
    actor.addListener(function(msg){
      if (msg.val) {
        return s.on();
      } else {
        return s.off();
      }
    });
    s.addListener(function(state){
      actor.sendEvent(state);
    });
    console.log('toggle-switch made');
  });
};
setPushButtons = function(){
  return $('.push-button').each(function(){
    var jqElem, pinName, actor;
    jqElem = $(this);
    pinName = jqElem.data('pin-name');
    actor = SwitchActor(pinName);
    jqElem.on('mousedown touchstart', function(){
      jqElem.addClass('button-active-state');
      actor.sendEvent(true);
      return jqElem.on('mouseleave', function(){
        jqElem.removeClass('button-active-state');
        return actor.sendEvent(false);
      });
    });
    jqElem.on('mouseup touchend touchcancel touchmove', function(){
      jqElem.removeClass('button-active-state');
      actor.sendEvent(false);
      return jqElem.off('mouseleave');
    });
    return actor.addListener(function(msg){
      if (msg.val) {
        return jqElem.addClass('button-active-state');
      } else {
        return jqElem.removeClass('button-active-state');
      }
    });
  });
};
setStatusLeds = function(){
  return $('.status-led').each(function(){
    var jqElem, pinName, actor;
    jqElem = $(this);
    pinName = jqElem.data('pin-name');
    actor = SwitchActor(pinName);
    actor.addListener(function(msg){
      return console.log("push button got message: ", msg);
    });
    return console.log(jqElem);
  });
};
app.on('complete', function(){
  console.log("ractive completed, post processing other widgets...");
  setSwitchButtons();
  setPushButtons();
  setStatusLeds();
});
socket.on("connect", function(){
  app.set("connected", true);
});
socket.on('disconnect', function(){
  console.log('disconnected...');
  app.set('connected', false);
});
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
function in$(x, xs){
  var i = -1, l = xs.length >>> 0;
  while (++i < l) if (x === xs[i]) return true;
  return false;
}
});

;require.register("init", function(exports, require, module) {
// Generated by LiveScript 1.3.1
require('app');
});

require.register("lib/testlibrary", function(exports, require, module) {
// Generated by LiveScript 1.3.1
var test;
test = function(){
  console.log("test lib is working!");
};
module.exports = {
  test: test
};
});

require.register("weblib", function(exports, require, module) {
// Generated by LiveScript 1.3.1
/*
require! {
  'prelude-ls': {
    flatten
    initial
    drop
    join
    concat
    tail
    head
    map
    zip
    split
    }
}
*/
/*
flatten = prelude.flatten
initial = prelude.initial
drop = prelude.drop
join = prelude.join
concat = prelude.concat
tail = prelude.tail
head = prelude.head
map = prelude.map
zip = prelude.zip
split = prelude.split
*/
var test, mkRealtimeInput, rotate, stateOf, mkRadiobox, radioboxHandler, radioboxListenerHandler, connectEnterToClick;
test = function(){
  return console.log('weblib library is working!');
};
mkRealtimeInput = function(node, timeout, handler){
  $(node).each(function(){
    var elem, dataKey, valFunc, typeAttr;
    elem = $(this);
    dataKey = 'mk-realtime-input.old-val';
    valFunc = function(){
      return elem.val();
    };
    typeAttr = elem.attr('type');
    if (typeAttr != null ? typeAttr : void 8) {
      if (elem.attr('type') === 'checkbox') {
        valFunc = function(){
          return elem.is(':checked');
        };
      }
    }
    elem.data(dataKey, valFunc());
    elem.bind("propertychange change click keyup input paste", function(event){
      var handlerWithParameter;
      if (elem.data(dataKey) !== valFunc()) {
        elem.data(dataKey, valFunc());
        handlerWithParameter = handler(elem);
        clearTimeout(elem.data('timeout'));
        elem.data('timeout', setTimeout(handlerWithParameter, timeout));
      }
    });
  });
};
rotate = function(array){
  return tail(array).concat([head(array)]);
};
stateOf = function(elem){
  return elem.is(':checked');
};
mkRadiobox = function(nodeId, handler, listenerHandler, socket){
  var buttons, buttons1f, buttons2f, i$, to$, i, len$, button, results$ = [];
  buttons = [];
  $(nodeId).children().each(function(){
    var elem;
    elem = $(this);
    if (elem.attr('type') === 'checkbox') {
      buttons.push(elem);
    }
  });
  buttons1f = rotate(buttons);
  buttons2f = rotate(buttons1f);
  for (i$ = 0, to$ = buttons.length - 1; i$ <= to$; ++i$) {
    i = i$;
    buttons1f[i].data({
      'next-button': buttons2f[i],
      'previous-button': buttons[i],
      'version': 0,
      'old-value': stateOf(buttons1f[i]),
      'id': i,
      'group-id': nodeId,
      'edge': false
    });
  }
  for (i$ = 0, len$ = buttons.length; i$ < len$; ++i$) {
    button = buttons[i$];
    listenerHandler(button, socket);
    results$.push(button.bind("propertychange click keyup chain", fn$));
  }
  return results$;
  function fn$(event){
    var currentButton, nextButton, previousButton, debugMessage, currentState;
    currentButton = $(event.target);
    nextButton = currentButton.data()['next-button'];
    previousButton = currentButton.data()['previous-button'];
    debugMessage = '';
    debugMessage += 'rb-event-handler: ';
    debugMessage += currentButton.attr('value') + ', ';
    currentState = stateOf(currentButton);
    if (previousButton.data()['version'] > currentButton.data()['version']) {
      currentButton.data()['version'] = previousButton.data()['version'];
    }
    debugMessage += 'state ';
    if (currentButton.data()['old-value'] !== currentState) {
      debugMessage += 'changed: ';
      debugMessage += currentButton.data()['old-value'];
      debugMessage += ' -> ';
      currentButton.data()['version'] += 1;
      handler(currentButton, event, socket);
      currentButton.data()['old-value'] = currentState;
      currentButton.data()['edge'] = true;
    } else {
      debugMessage += ' not changed: ';
      currentButton.data()['edge'] = false;
    }
    debugMessage += currentState;
    if (nextButton.data()['version'] < currentButton.data()['version']) {
      nextButton.trigger('chain');
    } else {}
    console.log(debugMessage);
  }
};
radioboxHandler = function(elem, event, socket){
  var currentButton, strJoin, radioboxMessage, radioboxGid, debugMessage;
  currentButton = elem;
  strJoin = join('');
  radioboxMessage = strJoin([elem.attr('value'), ' is changed to ', stateOf(elem).toString()]);
  radioboxGid = elem.data()['group-id'];
  debugMessage = '';
  debugMessage += 'rb-handler: ';
  debugMessage += radioboxGid + ': ';
  debugMessage += 'event.type: ' + event.type;
  if (stateOf(currentButton) !== currentButton.data()['old-value'] && event.type !== 'chain') {
    socket.emit('tweet', {
      user: radioboxGid,
      text: radioboxMessage
    });
  }
  if (false) {
    socket.emit('tweet', {
      user: 'debug',
      text: strJoin([elem.attr('value'), ': ', currentButton.data()['old-value'], ' -> ', stateOf(currentButton).toString()])
    });
  }
};
radioboxListenerHandler = function(elem, socket){
  var radioboxGid, domId, debugMessage1;
  radioboxGid = elem.data()['group-id'];
  domId = elem.attr('value');
  debugMessage1 = '';
  debugMessage1 += 'radiobox: ';
  debugMessage1 += 'handler added for ';
  debugMessage1 += radioboxGid + '.' + domId;
  socket.on('tweet', function(tweet){
    var debugMessage, changeLog, checkState, currentButton, b;
    debugMessage = '';
    debugMessage += 'rb-receiver: ';
    debugMessage += radioboxGid + '.' + domId;
    if (tweet.user === radioboxGid) {
      changeLog = split(' is changed to ', tweet.text);
      debugMessage += ', ';
      debugMessage += join('->', changeLog);
      if (changeLog[0] === domId) {
        checkState = changeLog[1] === 'true';
        elem.prop('checked', checkState);
        currentButton = elem;
        if (stateOf(currentButton) === true) {
          debugMessage += " unchecking other buttons, ";
          b = currentButton.data()['next-button'];
          while (b.data()['id'] !== currentButton.data()['id']) {
            b.prop('checked', false);
            b.trigger('chain');
            b = b.data()['next-button'];
          }
          return debugMessage += " unchecking other buttons DONE.";
        }
      }
    } else {
      return debugMessage += ' this msg is NOT for me';
    }
  });
};
connectEnterToClick = function(src, target){
  $('document').ready(function(){
    $(src).keypress(function(e){
      if (e.keyCode === 13) {
        $(target).click();
      }
    });
  });
};
module.exports = {
  test: test,
  mkRealtimeInput: mkRealtimeInput,
  mkRadiobox: mkRadiobox,
  rotate: rotate,
  stateOf: stateOf,
  radioboxHandler: radioboxHandler,
  radioboxListenerHandler: radioboxListenerHandler,
  connectEnterToClick: connectEnterToClick
};
});


//# sourceMappingURL=app.js.map